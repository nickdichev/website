---
import { CollectionEntry, getCollection } from "astro:content";
import FormattedDate from "../components/FormattedDate.astro";
import BaseLayout from "./BaseLayout.astro";
import TableOfContent from "../components/TableOfContent.astro";
import ScrollToTopButton from "../components/ScrollToTopButton";
import { Image } from "astro:assets";
import SeriesList from "../components/SeriesList.astro";
import SeriesCard from "../components/SeriesCard.astro";

type Blog = CollectionEntry<"blog">["data"];

type Heading = {
  depth: number;
  slug: string;
  text: string;
};

export interface Props extends Blog {
  readingTime: string;
  headings: Heading[];
}

const {
  title,
  description,
  tags,
  pubDate,
  updatedDate,
  cover,
  coverAlt,
  readingTime,
  headings,
  seriesId,
  orderInSeries,
} = Astro.props;

const series = (await getCollection("series")).find((s) => s.data.id === seriesId);
---

<BaseLayout title={title} description={description} postMeta={{ pubDate, tags }}>
  <div
    class="prose prose-slate max-w-none prose-headings:scroll-my-20 prose-a:underline-offset-2 prose-a:decoration-accent prose-img:rounded-lg dark:prose-invert blog-post-body"
  >
    <h1>{title}</h1>
    <div class="font-semibold text-xs uppercase space-y-2">
      <div class="flex flex-wrap items-center space-x-1">
        <span>
          Published on <FormattedDate date={pubDate} />
        </span>
        {
          updatedDate && (
            <>
              <span>{"•"}</span>
              <span>
                Updated on <FormattedDate date={updatedDate} />
              </span>
            </>
          )
        }
        <span>{"•"}</span>
        <span>{readingTime}</span>
      </div>
      <div class="flex space-x-2 items-center">
        {
          tags.map((tag) => (
            <a
              href={`/tags/${tag.slice(1)}`}
              class="no-underline bg-tag hover:bg-tag-hover p-1 px-4 rounded-full"
            >
              {tag}
            </a>
          ))
        }
      </div>
    </div>
    <div class="not-prose">
      {cover && coverAlt && <Image class="my-10 mb-1 rounded-lg" src={cover} alt={coverAlt} />}
    </div>
    <div class="md:flex space-x-10">
      <div class="w-full">
        <div class="not-prose my-10">
          {series && <SeriesCard series={series} order={orderInSeries} />}
        </div>
        <article class="article-with-asides">
          <slot />
        </article>
      </div>
      {
        headings.length > 0 && (
          <nav class="hidden text-sm space-y-2 mt-9 lg:block lg:w-4/12 h-screen sticky top-20 z-40">
            <span class="font-black text-text-heading uppercase">On This Page</span>
            <TableOfContent headings={headings} />
            <div class="border-border border-b-[1px]" />
            <div class="flex float-right">
              <ScrollToTopButton client:idle />
            </div>
          </nav>
        )
      }
    </div>
  </div>
</BaseLayout>

<script>
  const codeBlocks = Array.from(
    document.querySelectorAll("figure[data-rehype-pretty-code-figure]"),
  );

  for (let codeBlock of codeBlocks) {
    const codeBlockPre = codeBlock.getElementsByTagName("pre")[0];

    codeBlockPre.removeAttribute("style");

    // Copy button
    const copyButton = document.createElement("button");
    copyButton.className =
      "p-1 px-2 rounded-md text-code-text text-xs bg-code-button hover:bg-code-button-hover";
    copyButton.innerHTML = "Copy";

    // Header title
    const titleSpan = document.createElement("span");
    titleSpan.className = "text-accent-light";

    // Header div
    const headerDiv = document.createElement("div");
    headerDiv.className =
      "flex w-full bg-code-bg border-b-[0.5px] border-accent-light rounded-t-lg mt-10 text-base items-center justify-between py-2 px-4";

    // Current title
    const titleDiv = codeBlock.querySelector("figcaption[data-rehype-pretty-code-title]");

    // Set title to the language name if no current title is set
    if (titleDiv) {
      const title = titleDiv.innerHTML;
      titleSpan.innerHTML = title;
      codeBlock.removeChild(titleDiv);
    } else {
      titleSpan.innerHTML = codeBlockPre.getAttribute("data-language") as string;
    }

    headerDiv.appendChild(titleSpan);
    headerDiv.appendChild(copyButton);
    codeBlock.prepend(headerDiv);

    copyButton.addEventListener("click", async () => {
      await copyCode(codeBlock, copyButton);
    });
  }

  async function copyCode(block: Element, button: HTMLButtonElement) {
    const code = block.querySelector("code") as HTMLElement;
    const text = code.innerText as string;
    await navigator.clipboard.writeText(text);
    button.innerText = "Copied!";

    setTimeout(() => {
      button.innerText = "Copy";
    }, 750);
  }
</script>

<script>
  // Transform code comment patterns like "# (nix-enable)" into clickable markers.
  // Done client-side because rehype plugin can't reliably modify rehype-pretty-code output.
  function transformCodeMarkers() {
    let markerCount = 0;
    const codeBlocks = document.querySelectorAll("figure[data-rehype-pretty-code-figure] code");

    codeBlocks.forEach((code) => {
      // Walk every line span
      const lines = code.querySelectorAll("span[data-line]");
      lines.forEach((line) => {
        const text = line.textContent || "";
        const match = text.match(/(#|\/\/)\s*\(([a-zA-Z0-9_-]+)\)\s*$/);
        if (!match) return;

        markerCount++;
        const asideId = match[2];
        const pattern = match[0];

        // Walk the leaf text nodes to find and remove the pattern
        const walker = document.createTreeWalker(line, NodeFilter.SHOW_TEXT);
        const textNodes: Text[] = [];
        let node: Text | null;
        while ((node = walker.nextNode() as Text)) textNodes.push(node);

        // Build a map of cumulative positions
        let cumulative = 0;
        const positions = textNodes.map((tn) => {
          const start = cumulative;
          cumulative += tn.length;
          return { node: tn, start, end: cumulative };
        });

        const patternStart = text.lastIndexOf(pattern);
        const patternEnd = patternStart + pattern.length;

        // Remove or trim text nodes that overlap with the pattern
        for (const { node: tn, start, end } of positions) {
          if (start >= patternStart) {
            // Entirely within pattern — remove
            tn.textContent = "";
          } else if (end > patternStart) {
            // Straddles boundary — trim
            tn.textContent = tn.textContent!.slice(0, patternStart - start);
          }
        }

        // Append the clickable marker span
        const marker = document.createElement("span");
        marker.className = "code-aside-marker";
        marker.dataset.asideTarget = asideId;
        marker.setAttribute("role", "button");
        marker.setAttribute("tabindex", "0");
        marker.setAttribute("aria-label", "Go to sidenote");
        marker.textContent = `(${markerCount})`;
        line.appendChild(marker);
      });
    });
  }

  function positionAsides() {
    const article = document.querySelector(".article-with-asides");
    if (!article) return;

    const isDesktop = window.matchMedia("(min-width: 1024px)").matches;
    if (!isDesktop) return;

    const asides = article.querySelectorAll(".aside-container");
    const articleRect = article.getBoundingClientRect();
    const GAP = 12; // min px gap between stacked asides
    let lastBottom = 0;

    asides.forEach((aside) => {
      const content = aside.querySelector("[data-aside-content]") as HTMLElement;
      if (!content) return;

      const asideId = aside.getAttribute("data-aside-id");
      let referenceElement: Element | null = null;

      if (asideId) {
        referenceElement = document.querySelector(
          `.code-aside-marker[data-aside-target="${asideId}"]`
        );
      } else {
        referenceElement = aside.querySelector(".aside-marker-wrapper");
      }

      if (!referenceElement) return;

      const refRect = referenceElement.getBoundingClientRect();
      // Subtract padding so the aside text aligns with the marker
      let top = refRect.top - articleRect.top + article.scrollTop - 8;

      // Prevent overlap: push down if this would overlap the previous aside
      if (top < lastBottom + GAP) {
        top = lastBottom + GAP;
      }

      content.style.top = `${top}px`;

      // Track bottom edge for next aside
      lastBottom = top + content.offsetHeight;
    });
  }

  function handleCodeMarkerClicks() {
    const codeMarkers = document.querySelectorAll(".code-aside-marker");

    codeMarkers.forEach((marker) => {
      const handler = () => {
        const targetId = (marker as HTMLElement).dataset.asideTarget;
        if (!targetId) return;

        const targetAside = document.querySelector(
          `[data-aside-id="${targetId}"]`
        );
        if (!targetAside) return;

        const content = targetAside.querySelector("[data-aside-content]") as HTMLElement;
        if (!content) return;

        targetAside.scrollIntoView({ behavior: "smooth", block: "center" });

        content.classList.add("aside-highlighted");
        setTimeout(() => {
          content.classList.remove("aside-highlighted");
        }, 1500);
      };

      marker.addEventListener("click", handler);
      marker.addEventListener("keydown", (e: Event) => {
        if ((e as KeyboardEvent).key === "Enter" || (e as KeyboardEvent).key === " ") {
          e.preventDefault();
          handler();
        }
      });
    });
  }

  function initAsides() {
    transformCodeMarkers();
    positionAsides();
    handleCodeMarkerClicks();
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initAsides);
  } else {
    initAsides();
  }

  window.addEventListener("resize", positionAsides);
  window.addEventListener("load", positionAsides);
</script>
